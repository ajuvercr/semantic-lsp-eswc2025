<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Slides: Semantic Web Langauge Server</title><link rel="stylesheet" href="node_modules/@shower/ribbon/styles/styles.css"><link rel="stylesheet" href="./prism.css"><link rel="stylesheet" href="./local.css"><style>.shower {
    --slide-ratio: calc(16 / 9);
}</style></head><body class="shower list"><header class="caption"><h1>Semantic Web Language Server (SWLS)</h1><p>Enhancing the Developer Experience for Semantic Web Practitioners</p></header><section class="slide title"><h2>Semantic Web Language Server (SWLS)</h2><h4>Enhancing the Developer Experience for Semantic Web Practitioners</h4><div><em>Arthur Vercruysse</em>, Julián Rojas Meléndez, Pieter Colpaert <br> Ghent University - IMEC</div></section><section class="slide"><h2>Context</h2><ul><li>Semantic Web comes in many forms: Turtle, SPARQL, etc</li><li>When editing Linked Data, a human error is quickly made</li><li>Thanks to best practices, the source of truth is often <strong>available</strong> [1]</li></ul><h4>We introduce the Semantic Web Language Server (SWLS).</h4><p class="footer">[1]: <a href="https://lov.linkeddata.es/dataset/lov/">lov.linkeddata.es/dataset/lov/</a></p></section><section class="slide"><h2>Motivation</h2><p>Other tools exist but are limited</p><ul><li>Focus on a single language, Yasgui [2]</li><li>Focus on a single dataset, <a href="https://query.wikidata.org/">query.wikidata.org</a></li><li>Most lack local integrations</li></ul><p class="footer">[2]: <a href="https://yasgui.org/">yasgui.org/</a></p></section><section class="slide bg-inspirational"><div class="overlay"><blockquote class="large">What if writing RDF felt like writing code?</blockquote></div><small class="footer right">Picture by Greg Rakozy</small><figure><image class="cover" src="./images/inspirational.jpg"></image></figure></section><section class="slide bg-inspirational"><div class="overlay"><h1>We bring to you<strong><em>The Semantic Web Language Server</em></strong></h1></div><small class="footer right">Picture by Greg Rakozy</small><figure><image class="cover" src="./images/inspirational.jpg"></image></figure></section><section class="slide"><h2>What is the Semantic Web Language Server (SWLS)?</h2><ul><li>Language Server implementation in Rust (Bevy ECS-based)</li><li>Supports Turtle, JSON-LD, and SPARQL</li><li><strong>Features:</strong> completion, diagnostics, highlighting, formatting, hover</li></ul></section><section class="slide"><h2>Language Server Protocol</h2><ul><li>Standard JSON-RPC protocol.</li><li>Reduces integration complexity: <em>O(M+N)</em> instead of <em>O(M×N)</em>.</li><li>Cross-editor language support (VSCode, NeoVim, etc.).</li></ul><div class="image-row"><img src="https://upload.wikimedia.org/wikipedia/commons/9/9a/Visual_Studio_Code_1.35_icon.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/3/3a/Neovim-mark.svg"></div></section><section class="slide"><h2>Entity Component System (ECS)</h2><p>Originally created to handle data management in games, following composition over inheritance, all data is present in the <em>world</em></p><ul><li><strong>Entities:</strong> documents in the editor</li><li><strong>Components:</strong> data linked to entities</li><li><strong>Systems:</strong> function that acts on entities with the desired components</li><li><strong>Resources:</strong> static data linked to the <em>world</em></li></ul><p>Different systems are bundled in <em>schedules</em>.</p></section><section class="slide"><h2>File <em>index.ttl</em></h2><pre><code class="language-turtle">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/>.
<#you> a foaf:Person;
  foaf:knows [
    foaf:name "Arthur";
    foaf:lastName "Vercruysse";
  ].
</code></pre></section><section class="slide"><h2>Entity Component System (ECS)</h2><table><tr><th></th><th>Source</th><th>TurtleLang</th></tr><tr><td>index.ttl</td><td>The Source Code</td><td>Exists</td></tr></table></section><section class="slide"><h2>Turtle Parse System</h2><pre><code class="language-rust">pub fn parse_source(
    query: Query<
      (Entity, &Source), (Changed&lt;Source>, With&lt;TurtleLang>)
    >,
 ) {
    // Parse the source, add tokens, AST and prefixes to entity
 }

</code></pre></section><section class="slide"><h2>Entity Component System (ECS)</h2><table><tr><th></th><th>Turtle</th><th>Triples</th><th>Prefixes</th><th>Open</th></tr><tr><td>index.ttl</td><td>AST</td><td>5</td><td>1</td><td>Exists</td></tr></table></section><section class="slide"><h2>LOV System</h2><pre><code class="language-rust">pub fn fetch_lov_properties<C: Client + Resource>(
   query: Query&lt;&Prefixes, (Changed&lt;Prefixes>, With&lt;Open>)>,
   mut prefixes: Local&lt;HashSet&lt;String>>,
) {
   // Fetch LOV
   // Add document to ECS __world__
}

</code></pre></section><section class="slide"><h2>Entity Component System (ECS)</h2><table><tr><th></th><th>Turtle</th><th>Triples</th><th>Prefixes</th><th>Open</th><th>Links</th></tr><tr><td>index.ttl</td><td>AST</td><td>5</td><td>1</td><td>Exists</td><td>foaf.ttl</td></tr><tr><td>foaf.ttl</td><td>AST</td><td>1042</td><td>5</td><td>-</td><td>-</td></tr></table></section><section class="slide"><h2>Derive Classes</h2><pre><code class="language-rust">pub fn derive_classes(
    query: Query<
      (Entity, &Triples), (Changed&lt;Triples>, Without&lt;Dirty>)
    >,
 ) {
    // Extract classes from triples and add them to the entity
 }
</code></pre></section><section class="slide"><h2>Entity Component System (ECS)</h2><table><tr><th></th><th>Turtle</th><th>Triples</th><th>Prefixes</th><th>Open</th><th>Links</th><th>Properties</th><th>Classes</th></tr><tr><td>index.ttl</td><td>AST</td><td>5</td><td>1</td><td>Exists</td><td>foaf.ttl</td><td>-</td><td>-</td></tr><tr><td>foaf.ttl</td><td>AST</td><td>1042</td><td>5</td><td>-</td><td>-</td><td>64</td><td>5</td></tr></table></section><section class="slide"><h2>Entity Component System (ECS)</h2><p> Other operations like autocompletion work the same way:<br>Multiple small systems find their required data and transform that into the expected data structure.</p><p><strong>Autocompletion</strong> is powered by things like the <strong>defined classes</strong> and <strong>properties</strong> from linked entities but also by other services like prefix.cc</p></section><section class="slide"><h2>Key Points</h2><ul><li>ECS makes the SWLS very extendable</li><li>Many systems are language agnostic</li><li>Adding a language is as simple as adding a tokenizer and a parser</li></ul></section><section class="slide dark-slide" style="background: black; color: white"><h1 style="text-align: center; font-size: 3.5rem; margin-top: 30vh">Alright...</h1><h2 style="text-align: center; font-weight: 300">Could you finally show me something?</h2></section><section class="slide bg-inspirational"><div class="overlay bottom"><div class="large">Complete prefixes with prefix.cc</div></div><figure><image class="cover" src="./images/complete-1.png"></image></figure></section><section class="slide bg-inspirational"><div class="overlay bottom"><div class="large">Complete classes from foaf ontology</div></div><figure><image class="cover" src="./images/complete-2.png"></image></figure></section><section class="slide bg-inspirational"><div class="overlay bottom"><div class="large">Complete properties from foaf ontology</div></div><figure><image class="cover" src="./images/complete-3.png"></image></figure></section><section class="slide bg-inspirational"><div class="overlay bottom"><div class="large">SHACL validation with rudof</div></div><figure><image class="cover" src="./images/diagnostics.png"></image></figure></section><section class="slide"><h2>SWLS Capabilities</h2><div class="row"><ul><li><strong>Diagnostics</strong><ul><li>Syntax</li><li>Undefined prefixes/properties</li><li>Shape violations</li></ul></li><li><strong>Highlighting</strong><ul><li>Syntactic (numbers and IRIs)</li><li>Semantic (from ontology)</li></ul></li></ul><ul><li><strong>Completion</strong><ul><li>Syntax (keywords, prefixes)</li><li>Semantic (typed suggestions)</li></ul></li><li><strong>Formatting</strong></li><li><strong>Renaming</strong></li></ul></div></section><section class="slide"><h2>SWLS availability</h2><ul><li><strong>VSCode:</strong> Web Extension to download</li><li><strong>NeoVim:</strong> Binary to install and configure with <em>nvim-lspconfig</em></li><li><strong>Web demo:</strong> Demonstrates capabilities with 4 different editor panels</li></ul></section><section class="slide"><h2>Conclusion</h2><ul><li>SWLS boosts accessibility and productivity.</li><li>Editor-agnostic and modular.</li><li>Try the online  Demo][3]!</li><li>Open source: pull requests are welcome <br> <a href="https://github.com/ajuvercr/semantic-web-lsp">github.com/ajuvercr/semantic-web-lsp</a>.</li></ul><div class="p footer">[1]: <a href="https://ajuvercr.github.io/semantic-web-lsp/">ajuvercr.github.io/semantic-web-lsp/</a></div></section><script src="node_modules/@shower/core/dist/shower.js"></script><script src="./prism.js"></script></body></html>