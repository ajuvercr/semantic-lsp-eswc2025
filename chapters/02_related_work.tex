% \section{Related Work}%
% \label{sec:related_work}
%
% In this section we look at the related state of the art.
% The state of the art is full of different implementations that handle some specific part of the semantic web.
% From ontology designers like protege to Yasgui's sparql query editors.
% This section covers the different IDE functionalities that can be implemented for the semantic web, Table 1 provides details on current and open-source implementations that implement parts of these functionalities.
%
% \paragraph*{Highlighting}
%
% Highlighting helps human brains parse data more easily.
% There are two different parts of highlighting: syntactic highlighting and semantic highlighting.
% The former only concerns itself with the syntax of a document. A lexer can handle this highlighting very effectively and allows for example to hightlight strings as green and namednodes as red.
% Semnatic highlighting on the other hand can use document semantics. Semantics can be for example the term kind of a term, only inferable by extracting the actual triples or marking the type of an object in a different colour.
%
% Please note that undefined properties etc should not be highlighed differently by the semantic highlighter, undefined properties should be handled as diagnostics.
%
%
% \paragraph*{Diagnostics}
%
% Diagnostics are of utmost importance, nothing is more draining than to check whether or not some data is correctly written at runtime.
% The editor should be able to notify the user that the current document would not be parsed by parsers following the standard.
%
% Other diagnostics are also very relevant and can inform the user that the current data may not be what they expect.
% For example the editor can notify the user when an undefined property is used, alerting the user that it could be a typo.
% The editor can also notify the user about reasoning mistakes, when creating an ontology or creating data that should adhere to an ontology or to a SHACL shape.
%
%
% \paragraph*{Formatting}
%
% It is expected that an IDE helps the developer to keep a consistent format over different documents, again helping the user parse the data more effectively.
% Formatting however is a subjective matter and should be configurable by the user or codebase.
%
% \paragraph*{Renaming}
% Often an editor allows the user to rename identifiers as a quality of life improvemt.
% This allows the user to more easily iterate over data and aliviating the writer's block.
%
%
% \paragraph*{Completion}
%
% Completion comes again in two flavours: completing keywords and already defined tokens and semantic completion.
% Semantic completion can complete with defined properties and defined classes and can check the current context of the completion, answering the question "Is the user current writing a class or a property?".
%
% Naive completion can suggest all defined properties and defined classes but this is not always wanted, the editor should also be able to derive the type of the current subject for example and only suggest properties that are defined with that type as domain.
% On the other hand when the user is writing an object, the editor can also suggest already defined entities that have the correct type checking the range of the property.
%
%
%
%
%
% \subsection*{Some words on ontology designing tools}
% Their main helping functions~\cite{ComparingOntologyBuildingTools}.
%
% \subsection{Language Server Protocol}
%
% Language Servers using the Language Server Protocol~\cite{IntroToLsp} 
% are cool ~\cite{GLSPFlexibility}.
%


%% GPT

\section{State of the Art}%
\label{sec:related_work}

%PC: I’d consider renaming related work state of the art then!
This section examines the state of the art in tools and functionalities that support developement and interaction with Semantic Web technologies. 
Current implementations address various aspects of Semantic Web technologies, including for example, ontology modeling tools (e.g., Protégé) and SPARQL query editors (e.g., YASGUI).
Next we describe a set of common IDE functionalities~\cite{HowAreJava} and discuss existing tools that (partially) cover them for Semantic Web-related formats.

\paragraph*{Highlighting} enhances readability by leveraging visual cues, which assist developers in understanding complex data.
For example by colouring differently reserved keywords (e.g., \texttt{a}, \texttt{@prefix} in the RDF Turtle syntax) and data types (e.g., strings, numbers, etc.).  
% Semantic highlighters should avoid overloading the user with unnecessary information. 
% Undefined properties, for example, should not be highlighted differently; such cases are better addressed by diagnostic features.~\todoCite{This needs to be backed by a citation. Otherwise just limit to explain what is highlighting and why is important.}
There are two primary types of highlighting: \textbf{syntactic} and \textbf{semantic}.

\begin{itemize}
    \item \textbf{Syntactic highlighting} focuses on document syntax and is implemented using lexers (i.e. software that transforms text into tokens: keyswords, IRIs, blanknode identifiers, etc.).
      For example in RDF Turtle, strings might appear in green, while named nodes are highlighted in red.
      This type of highlighting does not require knowledge of the document's meaning.
      Syntactic highlighting is enabled on all software we considered, except for the 
      \textit{rdf-vocabularies-autocomplete} VSCode extension, VSCode handles syntactic highlighting already with the Tree-sitter project\footnote{\url{https://tree-sitter.github.io/tree-sitter/}}.
    \item \textbf{Semantic highlighting}, in contrast, uses the local (and externally linked) semantics referenced in the document to differentiate terms based on their roles. 
      For instance, terms declared in an ontology can be highlighted differently compared to locally defined terms.
      We found no semantic web tooling that implemented this feature.
\end{itemize}


\paragraph*{Diagnostics} are essential for identifying issues early in the development process. 
Rather than deferring error detection to runtime, an IDE should provide immediate feedback on data validity and correctness.
These features enable developers to maintain data accuracy and reduce time spent debugging. 
The stardog language servers and the Yasgui query editor notify the users of syntax errors.

% Examples of valuable diagnostics include:
\begin{itemize}
    \item \textbf{Standard compliance}: Notifying users if the current document is incompatible with parsers adhering to Semantic Web standards.
    \item \textbf{Undefined properties}: Alerting users to potential typing mistakes or incorrect terms when undefined properties are detected.
    \item \textbf{Reasoning errors}: Highlighting logical inconsistencies in ontologies or data that deviate from expected SHACL shapes or OWL reasoning constraints.
\end{itemize}


\paragraph*{Formatting} 
Consistent formatting across documents can help enhancing readability and maintainability.
IDEs assist users in adhering to a defined style guide while allowing customization to accommodate different workflows or preferences.
We found no semantic web tooling that implemented this feature.

\paragraph*{Renaming} identifiers, such as classes or properties, is an important feature for iterative development.
This functionality helps users manage data more efficiently and adapt to evolving project requirements without introducing errors.
We found no semantic web tooling except for our previous work~\cite{JSONLD-LSP}, that handles renaming identifiers.

\paragraph*{Completion} features, similar to highlighting, can be categorized as \textbf{syntactic} or \textbf{semantic}:
Simple semantic completion might suggest all possible terms, but a sophisticated system should filter suggestions based on the context, such as the inferred type of the current subject or object.
All semantic web tooling we considered, included some kind of completion mechanism, none however applied typed completion.


\begin{itemize}
    \item \textbf{Syntactic completion} involves suggesting keywords or tokens already defined in the document.
    \item \textbf{Semantic completion} provides context-aware suggestions, such as properties or classes relevant to the current position. For example:
    \begin{itemize}
        \item When writing a property in an RDF document, the IDE can suggest those that define the subject's type as their \texttt{rdfs:domain}.
        \item When completing an object, it can suggest entities consistent with the property's \texttt{rdfs:range}.
    \end{itemize}
\end{itemize}

In Table~\ref{tab:current_implementations} we show a summary of exisiting open-source tools that implement at least one of the aforementioned IDE functionalities for Semantic Web technologies.
% PC: This is something you’d like the reader to accept indeed when you introduced the SOTA entirely. I’d put this sentence at the end.
While these tools provide specialized capabilities, the integration of features typical of IDEs remains limited.
With SWLS we aim on addressing this gap and in general, support the broader adoption of Semantic Web technologies. 

% we might want to transpose the headers
\begin{table}[h!]
    \centering
  \begin{tabularx}{\textwidth}{ |p{3cm}|C|C|C|C|C|C|C|C|C|C|C|C|}
\hline
    \multirow{2}{*}{} & \multicolumn{2}{c|}{Highlight} & \multicolumn{3}{c|}{Diagnostics} & \multicolumn{4}{c|}{Completion}  & \multirow{2}{*}{} & \multirow{2}{*}{} & \multirow{2}{*}{} \\ \cline{2-10} 

      LSP implementation                & \rotatebox{90}{Syntactic} & \rotatebox{90}{Semantic} %highlighting
                                        & \rotatebox{90}{Syntax} & \rotatebox{90}{Undefined} & \rotatebox{90}{Validation\ \ }  %diagnostics
                                        & \rotatebox{90}{Syntax} & \rotatebox{90}{Tokens} & \rotatebox{90}{Simple} & \rotatebox{90}{Typed} % completion
                                        & \rotatebox{90}{Formatting} 
                                        & \rotatebox{90}{Renaming}
                                        & \rotatebox{90}{Polyglot} \\ \hline
Stardog                       & \cmark & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \mmark & \xmark & \xmark & \xmark & \cmark \\
RDFox                         & \cmark & \xmark & \xmark & \xmark & \xmark & \mmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark \\
query.wikidata                & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark \\
yasgui                        & \cmark & \xmark & \cmark & \xmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark \\
Protégé                       & N/A    & N/A    & N/A    & N/A    & \cmark & N/A    & \cmark & N/A    & N/A    & N/A    & \cmark & \xmark \\
rdf-vocabularies-autocomplete & N/A    & N/A    & N/A    & N/A    & N/A    & \xmark & \xmark & \cmark & \xmark & N/A    & N/A    & \xmark \\
JSON-LD LSP                   & \cmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark & \xmark \\
SWLS                          & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
\hline
\end{tabularx}
    \caption{\label{tab:current_implementations}
    \mmark Stardog simple completion is based on a fixed list of items. 
    \mmark RDFox syntax completion is only based on predefined for SPARQL functions.
    Table listing IDE features of different Semantic Web tools.
    All eligable software supports both highlighting and completion in one form of another, 
    while no software supports formatting or renaming except for Protégé and JSONLD-LSP (our previous work). 
  }
\end{table}


\subsection*{Ontology Design Tools}

Ontology design tools, such as Protégé~\cite{protege2015}, serve as the foundation for many Semantic Web development workflows. 
Their primary functions include visualizing ontologies, defining classes and properties, and validating logical consistency through reaoning.
These tools provide essential support but often lack the integrated functionality of modern IDEs, such as context-aware diagnostics or advanced refactoring capabilities~\cite{ComparingOntologyBuildingTools}.


