@article{Berners-Lee_SA_2001,
  author  = {Berners-Lee, Tim and Hendler, James and Lassila, Ora},
  journal = {Scientific American},
  number  = {5},
  pages   = {34-43},
  title   = {The Semantic Web},
  url     = {http://www.sciam.com/article.cfm?articleID=00048144-10D2-1C70-84A9809EC588EF21},
  volume  = {284},
  year    = {2001}
}

@article{protege2015,
  author    = {Mark A. Musen},
  title     = {The prot{\'{e}}g{\'{e}} project: a look back and a look forward},
  journal   = {{AI} Matters},
  volume    = {1},
  number    = {4},
  pages     = {4--12},
  year      = {2015},
  url       = {https://doi.org/10.1145/2757001.2757003},
  doi       = {10.1145/2757001.2757003},
  timestamp = {Wed, 14 Nov 2018 10:27:16 +0100},
  biburl    = {https://dblp.org/rec/journals/aimatters/Musen15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{LOV2017,
  author     = {Dumontier, Michel and Vandenbussche, Pierre-Yves and Atemezing, Ghislain A. and Poveda-Villal\'{o}n, Mar\'{\i}a and Vatant, Bernard},
  title      = {Linked Open Vocabularies (LOV): A gateway to reusable semantic vocabularies on the Web},
  year       = {2017},
  issue_date = {2017},
  publisher  = {IOS Press},
  address    = {NLD},
  volume     = {8},
  number     = {3},
  issn       = {1570-0844},
  url        = {https://doi.org/10.3233/SW-160213},
  doi        = {10.3233/SW-160213},
  abstract   = {One of the major barriers to the deployment of Linked Data is the difficulty that data publishers have in determining which vocabularies to use to describe the semantics of data. This systematic report describes Linked Open Vocabularies (LOV), a high-quality catalogue of reusable vocabularies for the description of data on the Web. The LOV initiative gathers and makes visible indicators such as the interconnections between vocabularies and each vocabulary’s version history, along with past and current editor (individual or organization). The report details the various components of the system along with some innovations, such as the introduction of a property-level boost in the vocabulary search scoring that takes into account the property’s type (e.g., dc:comment) associated with a matching literal value. By providing an extensive range of data access methods (full-text search, SPARQL endpoint, API, data dump or UI), the project aims at facilitating the reuse of well-documented vocabularies in the Linked Data ecosystem. The adoption of LOV by many applications and methods shows the importance of such a set of vocabularies and related features for ontology design and the publication of data on the Web.},
  journal    = {Semant. Web},
  month      = jan,
  pages      = {437–452},
  numpages   = {16},
  keywords   = {vocabulary catalogue, Linked Data, ontology search, Linked Open Vocabularies, LOV}
}

@article{yasgui,
  author     = {Hyv\"{o}nen, Eero and Rietveld, Laurens and Hoekstra, Rinke},
  title      = {The YASGUI family of SPARQL clients1},
  year       = {2017},
  issue_date = {2017},
  publisher  = {IOS Press},
  address    = {NLD},
  volume     = {8},
  number     = {3},
  issn       = {1570-0844},
  url        = {https://doi.org/10.3233/SW-150197},
  doi        = {10.3233/SW-150197},
  abstract   = {The size and complexity of the Semantic Web and its technology stack makes it difficult to query. Access to Linked Data could be greatly facilitated if it were supported by a tool with a strong focus on usability. In this paper we present the YASGUI family of SPARQL clients, a continuation of the YASGUI tool introduced more than two years ago. The YASGUI family of SPARQL clients enables publishers to improve ease of access for their SPARQL endpoints, and gives consumers of Linked Data a robust, feature-rich and user friendly SPARQL editor.We show that the YASGUI family had significant impact on the landscape of Linked Data management: YASGUI components are integrated in state-of-the-art triple-stores and Linked Data applications, and used as front-end by a large number of Linked Data publishers. Additionally, we show that the YASGUI web service – which provides access to any SPARQL endpoint – has a large and growing user base amongst Linked Data consumers.},
  journal    = {Semant. Web},
  month      = jan,
  pages      = {373–383},
  numpages   = {11},
  keywords   = {Linked Data, data publishing, query formulation, SPARQL}
}

@inproceedings{GLSPFlexibility,
  doi       = { 10.1007/978-3-031-48583-1\_7 },
  year      = { 2023 },
  publisher = { Springer International Publishing },
  pages     = { 109--124 },
  url       = { https://model-engineering.info/publications/papers/2023-PoEM-GLSP-FLexibility-CR-web.pdf },
  title     = { A Vision for Flexible GLSP-based Web Modeling Tools },
  editor    = { Jo{\~{a}}o Paulo A. Almeida and Monika Kaczmarek{-}He{\ss} and Agnes Koschmider and Henderik A. Proper },
  booktitle = { 16th IFIP WG 8.1 Working Conference on the Practice of Enterprise Modelling (PoEM'2023) },
  author    = { Dominik Bork and Philip Langer and Tobias Ortmayr }
}
×
@inproceedings{Heyvaert2018Declarative,
  author    = {Heyvaert, Pieter and De Meester, Ben and Dimou, Anastasia and Verborgh, Ruben},
  title     = {{Declarative Rules for Linked Data Generation at your Fingertips!}},
  booktitle = {Proceedings of the 15\textsuperscript{th} ESWC: Posters and Demos},
  year      = {2018}
}
@article{IntroToLsp,
  pages   = { 1--16 },
  number  = { 9 },
  volume  = { 18 },
  year    = { 2023 },
  doi     = { 10.18417/emisa.18.9 },
  journal = { Enterprise Modelling and Information Systems Architectures - International Journal of Conceptual Modeling },
  title   = { Language Server Protocol - An Introduction to the Protocol, its Use, and Adoption for Web Modeling Tools },
  author  = { Dominik Bork and Philip Langer }
}

@article{Bour_2018,
  title     = {Merlin: a language server for OCaml (experience report)},
  volume    = {2},
  issn      = {2475-1421},
  url       = {http://dx.doi.org/10.1145/3236798},
  doi       = {10.1145/3236798},
  number    = {ICFP},
  journal   = {Proceedings of the ACM on Programming Languages},
  publisher = {Association for Computing Machinery (ACM)},
  author    = {Bour, Frédéric and Refis, Thomas and Scherer, Gabriel},
  year      = {2018},
  month     = jul,
  pages     = {1–15}
}
@article{ComparingOntologyBuildingTools,
  author  = {Kapoor, Bhaskar and Savita, Sharma},
  year    = {2010},
  month   = {07},
  pages   = {},
  title   = {A Comparative Study Ontology Building Tools for Semantic Web Applications},
  volume  = {1},
  journal = {International Journal of Web \& Semantic Technology},
  doi     = {10.5121/ijwest.2010.1301}
}

@article{EvensteinSigalov2023,
  author   = {Evenstein Sigalov, Shani
              and Nachmias, Rafi},
  title    = {Investigating the potential of the semantic web for education: Exploring Wikidata as a learning platform},
  journal  = {Education and Information Technologies},
  year     = {2023},
  month    = {Oct},
  day      = {01},
  volume   = {28},
  number   = {10},
  pages    = {12565-12614},
  abstract = {Wikidata is a free, multilingual, open knowledge-base that stores structured, linked data. It has grown rapidly and as of December 2022 contains over 100 million items and millions of statements, making it the largest semantic knowledge-base in existence. Changing the interaction between people and knowledge, Wikidata offers various learning opportunities, leading to new applications in sciences, technology and cultures. These learning opportunities stem in part from the ability to query this data and ask questions that were difficult to answer in the past. They also stem from the ability to visualize query results, for example on a timeline or a map, which, in turn, helps users make sense of the data and draw additional insights from it. Research on the semantic web as learning platform and on Wikidata in the context of education is almost non-existent, and we are just beginning to understand how to utilize it for educational purposes. This research investigates the Semantic Web as a learning platform, focusing on Wikidata as a prime example. To that end, a methodology of multiple case studies was adopted, demonstrating Wikidata uses by early adopters. Seven semi-structured, in-depth interviews were conducted, out of which 10 distinct projects were extracted. A thematic analysis approach was deployed, revealing eight main uses, as well as benefits and challenges to engaging with the platform. The results shed light on Wikidata's potential as a lifelong learning process, enabling opportunities for improved Data Literacy and a worldwide social impact.},
  issn     = {1573-7608},
  doi      = {10.1007/s10639-023-11664-1},
  url      = {https://doi.org/10.1007/s10639-023-11664-1}
}

@article{10.1145/3236798,
  author     = {Bour, Fr\'{e}d\'{e}ric and Refis, Thomas and Scherer, Gabriel},
  title      = {Merlin: a language server for OCaml (experience report)},
  year       = {2018},
  issue_date = {September 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {2},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3236798},
  doi        = {10.1145/3236798},
  abstract   = {We report on the experience of developing Merlin, a language server for the OCaml programming language in development since 2013. Merlin is a daemon that connects to your favourite text editor and provides services that require a fine-grained understanding of the programming language syntax and static semantics: instant feedback on warnings and errors, autocompletion, "type of the code under the cursor", "go to definition", etc.  Language servers need to handle incomplete and partially-incorrect programs, and try to be incremental to minimize recomputation after small editing actions. Merlin was built by carefully adapting the existing tools (the OCamllex lexer and Menhir parser generators) to better support incrementality, incompleteness and error handling. These extensions are elegant and general, as demonstrated by the interesting, unplanned uses that the OCaml community found for them. They could be adapted to other frontends -- in any language.  Besides incrementality, we discuss the way Merlin communicates with editors, describe the design decisions that went into some demanding features and report on some of the non-apparent difficulties in building good editor support, emerging from expressive programming languages or frustrating tooling ecosystems.  We expect this experience report to be of interest to authors of interactive language tooling for any programming language; many design choices may be reused, and some hard-won lessons can serve as warnings.},
  journal    = {Proc. ACM Program. Lang.},
  month      = jul,
  articleno  = {103},
  numpages   = {15},
  keywords   = {syntax error recovery, parsing, language servers, incrementality, incremental typing, incremental parsing, Development environments}
}
@inproceedings{10.1145/3563834.3567537,
  author    = {Marr, Stefan and Burchell, Humphrey and Niephaus, Fabio},
  title     = {Execution vs. Parse-Based Language Servers: Tradeoffs and Opportunities for Language-Agnostic Tooling for Dynamic Languages},
  year      = {2022},
  isbn      = {9781450399081},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3563834.3567537},
  doi       = {10.1145/3563834.3567537},
  abstract  = {With the wide adoption of the language server protocol, the desire to have IDE-style tooling even for niche and research languages has exploded. The Truffle language framework facilitates this desire by offering an almost zero-effort approach to language implementers to providing IDE features. However, this existing approach needs to execute the code being worked on to capture much of the information needed for an IDE, ideally with full unit-test coverage.  
               
               To capture information more reliably and avoid the need to execute the code being worked on, we propose a new parse-based design for language servers. Our solution provides a language-agnostic interface for structural information, with which we can support most common IDE features for dynamic languages.  
               
               Comparing the two approaches, we find that our new parse-based approach requires only a modest development effort for each language and has only minor tradeoffs for precision, for instance for code completion, compared to Truffle's execution-based approach.  
               
               Further, we show that less than 1,000 lines of code capture enough details to provide much of the typical IDE functionality, with an order of magnitude less code than ad hoc language servers. We tested our approach for the custom parsers of Newspeak and SOM, as well as SimpleLanguage's ANTLR grammar without any changes to it. Combining both parse and execution-based approaches has the potential to provide good and precise IDE tooling for a wide range of languages with only small development effort. By itself, our approach would be a good addition to the many libraries implementing the language server protocol to enable low-effort implementations of IDE features.},
  booktitle = {Proceedings of the 18th ACM SIGPLAN International Symposium on Dynamic Languages},
  pages     = {1–14},
  numpages  = {14},
  keywords  = {comparison, execution time, language server protocol, parse time},
  location  = {Auckland, New Zealand},
  series    = {DLS 2022}
}
@inproceedings{10.1145/3550355.3552452,
  author    = {Barros, Djonathan and Peldszus, Sven and Assun\c{c}\~{a}o, Wesley K. G. and Berger, Thorsten},
  title     = {Editing support for software languages: implementation practices in language server protocols},
  year      = {2022},
  isbn      = {9781450394666},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3550355.3552452},
  doi       = {10.1145/3550355.3552452},
  abstract  = {Effectively using software languages, be it programming or domain-specific languages, requires effective editing support. Modern IDEs, modeling tools, and code editors typically provide sophisticated support to create, comprehend, or modify instances---programs or models---of particular languages. Unfortunately, building such editing support is challenging. While the engineering of languages is well understood and supported by modern model-driven techniques, there is a lack of engineering principles and best practices for realizing their editing support. Especially domain-specific languages---often created by smaller organizations or individual developers, sometimes even for single projects---would benefit from better methods and tools to create proper editing support.We study practices for implementing editing support in 30 so-called language servers---implementations of the language server protocol (LSP). The latter is a recent de facto standard to realize editing support for languages, separated from the editing tools (e.g., IDEs or modeling tools), enhancing the reusability and quality of the editing support. Witnessing the LSP's popularity---a whopping 121 language servers are in existence today---we take this opportunity to analyze the implementations of 30 language servers, some of which support multiple languages. We identify concerns that developers need to take into account when developing editing support, and we synthesize implementation practices to address them, based on a systematic analysis of the servers' source code. We hope that our results shed light on an important technology for software language engineering, that facilitates language-oriented programming and systems development, including model-driven engineering.},
  booktitle = {Proceedings of the 25th International Conference on Model Driven Engineering Languages and Systems},
  pages     = {232–243},
  numpages  = {12},
  keywords  = {code assistance, implementation practices, language engineering, source code editor},
  location  = {Montreal, Quebec, Canada},
  series    = {MODELS '22}
}
@article{10.1145/1922649.1922658,
  author     = {Ko, Amy J. and Abraham, Robin and Beckwith, Laura and Blackwell, Alan and Burnett, Margaret and Erwig, Martin and Scaffidi, Chris and Lawrance, Joseph and Lieberman, Henry and Myers, Brad and Rosson, Mary Beth and Rothermel, Gregg and Shaw, Mary and Wiedenbeck, Susan},
  title      = {The state of the art in end-user software engineering},
  year       = {2011},
  issue_date = {April 2011},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {43},
  number     = {3},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/1922649.1922658},
  doi        = {10.1145/1922649.1922658},
  abstract   = {Most programs today are written not by professional software developers, but by people with expertise in other domains working towards goals for which they need computational support. For example, a teacher might write a grading spreadsheet to save time grading, or an interaction designer might use an interface builder to test some user interface design ideas. Although these end-user programmers may not have the same goals as professional developers, they do face many of the same software engineering challenges, including understanding their requirements, as well as making decisions about design, reuse, integration, testing, and debugging. This article summarizes and classifies research on these activities, defining the area of End-User Software Engineering (EUSE) and related terminology. The article then discusses empirical research about end-user software engineering activities and the technologies designed to support them. The article also addresses several crosscutting issues in the design of EUSE tools, including the roles of risk, reward, and domain complexity, and self-efficacy in the design of EUSE tools and the potential of educating users about software engineering principles.},
  journal    = {ACM Comput. Surv.},
  month      = apr,
  articleno  = {21},
  numpages   = {44},
  keywords   = {End-user software engineering, end-user development, end-user programming, human-computer interaction, visual programming}
}
@article{10.3233/SW-190387,
  author     = {Hitzler, Pascal and Janowicz, Krzysztof and Hogan, Aidan},
  title      = {The Semantic Web: Two decades on},
  year       = {2020},
  issue_date = {2020},
  publisher  = {IOS Press},
  address    = {NLD},
  volume     = {11},
  number     = {1},
  issn       = {1570-0844},
  url        = {https://aidanhogan.com/docs/semantic-web-now.pdf},
  doi        = {10.3233/SW-190387},
  abstract   = {More than two decades have passed since the establishment of the initial cornerstones of the Semantic Web. Since its inception, opinions have remained divided regarding the past, present and potential future impact of the Semantic Web. In this paper – and in light of the results of over two decades of development on both the Semantic Web and related technologies – we reflect on the current status of the Semantic Web, the impact it has had thus far, and future challenges. We first review some of the external criticism of this vision that has been put forward by various authors; we draw together the individual critiques, arguing both for and against each point based on the current state of adoption. We then present the results of a questionnaire that we have posed to the Semantic Web mailing list in order to understand respondents’ perspective(s) regarding the degree to which the original Semantic Web vision has been realised, the impact it can potentially have on the Web (and other settings), its success stories thus far, as well as the degree to which they agree with the aforementioned critiques of the Semantic Web in terms of both its current state and future feasibility. We conclude by reflecting on future challenges and opportunities in the area.},
  journal    = {Semant. Web},
  month      = jan,
  pages      = {169–185},
  numpages   = {17},
  keywords   = {Semantic Web, ontologies, Linked Data, knowledge graphs}
}
@article{10.3233/SW-150197,
  author     = {Hyv\"{o}nen, Eero and Rietveld, Laurens and Hoekstra, Rinke},
  title      = {The YASGUI family of SPARQL clients1},
  year       = {2017},
  issue_date = {2017},
  publisher  = {IOS Press},
  address    = {NLD},
  volume     = {8},
  number     = {3},
  issn       = {1570-0844},
  url        = {https://doi.org/10.3233/SW-150197},
  doi        = {10.3233/SW-150197},
  abstract   = {The size and complexity of the Semantic Web and its technology stack makes it difficult to query. Access to Linked Data could be greatly facilitated if it were supported by a tool with a strong focus on usability. In this paper we present the YASGUI family of SPARQL clients, a continuation of the YASGUI tool introduced more than two years ago. The YASGUI family of SPARQL clients enables publishers to improve ease of access for their SPARQL endpoints, and gives consumers of Linked Data a robust, feature-rich and user friendly SPARQL editor.We show that the YASGUI family had significant impact on the landscape of Linked Data management: YASGUI components are integrated in state-of-the-art triple-stores and Linked Data applications, and used as front-end by a large number of Linked Data publishers. Additionally, we show that the YASGUI web service – which provides access to any SPARQL endpoint – has a large and growing user base amongst Linked Data consumers.},
  journal    = {Semant. Web},
  month      = jan,
  pages      = {373–383},
  numpages   = {11},
  keywords   = {Linked Data, data publishing, query formulation, SPARQL}
}

@article{Turki2021RepresentingCI,
  title   = {Representing COVID-19 information in collaborative knowledge graphs: The case of Wikidata},
  author  = {Houcemeddine Turki and Mohamed Ali Hadj Taieb and Thomas and Shafee and Tiago Lubiana and Dariusz Jemielniak and Mohamed Ben Aouicha and Jose Emilio Labra Gayo and E. Youngstrom and Diptanshu and Das and Daniel Mietchen},
  journal = {Semantic Web},
  year    = {2021},
  volume  = {13},
  pages   = {233-264},
  url     = {https://api.semanticscholar.org/CorpusID:235342949}
}
@article{javaEngineer,
  author  = {Murphy, Gail and Kersten, Mik and Findlater, Leah},
  year    = {2006},
  month   = {07},
  pages   = {76-83},
  title   = {How Are Java Software Developers Using the Eclipse IDE?},
  volume  = {23},
  journal = {IEEE Software},
  doi     = {10.1109/MS.2006.105}
}

@inproceedings{10.1007/978-3-642-41242-4_7,
  author    = {Rietveld, Laurens
               and Hoekstra, Rinke},
  editor    = {Cimiano, Philipp
               and Fern{\'a}ndez, Miriam
               and Lopez, Vanessa
               and Schlobach, Stefan
               and V{\"o}lker, Johanna},
  title     = {YASGUI: Not Just Another SPARQL Client},
  booktitle = {The Semantic Web: ESWC 2013 Satellite Events},
  year      = {2013},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {78--86},
  abstract  = {This paper introduces YASGUI, a user-friendly SPARQL client. We compare YASGUI with other SPARQL clients, and show the added value and ease of integrating Web APIs, services, and new technologies such as HTML5. Finally, we discuss some of the challenges we encountered in using these technologies for a building robust and feature rich web application.},
  isbn      = {978-3-642-41242-4}
}
@article{01GPAWNQ5ZS2DAY0J9JMPQHM9C,
  author   = {{Taelman, Ruben and Van Herwegen, Joachim and Vander Sande, Miel and Verborgh, Ruben}},
  issn     = {{1570-0844}},
  journal  = {{SEMANTIC WEB}},
  keywords = {{Dependency injection,inversion of control,RDF,linked data}},
  language = {{eng}},
  number   = {{1}},
  pages    = {{135--153}},
  title    = {{Components.js : semantic dependency injection}},
  url      = {{http://doi.org/10.3233/SW-222945}},
  volume   = {{14}},
  year     = {{2023}}
}
@inproceedings{CJS2,
  added-at  = {2023-03-10T00:00:00.000+0100},
  author    = {Herwegen, Joachim Van and Taelman, Ruben and Capadisli, Sarven and Verborgh, Ruben},
  biburl    = {https://www.bibsonomy.org/bibtex/28120bace3b466af89b97eafb9359104e/dblp},
  booktitle = {SemSci@ISWC},
  editor    = {Garijo, Daniel and van Hage, Willem Robert and Kauppinen, Tomi and Kuhn, Tobias and Zhao, Jun},
  ee        = {https://ceur-ws.org/Vol-1931/paper-04.pdf},
  interhash = {ad8b62c6557376fc9b74cb2252dbc000},
  intrahash = {8120bace3b466af89b97eafb9359104e},
  keywords  = {dblp},
  pages     = {23-30},
  publisher = {CEUR-WS.org},
  series    = {CEUR Workshop Proceedings},
  timestamp = {2024-04-09T11:33:05.000+0200},
  title     = {Describing Configurations of Software Experiments as Linked Data.},
  url       = {http://dblp.uni-trier.de/db/conf/semweb/semsci2017.html#HerwegenTCV17},
  volume    = 1931,
  year      = 2017
}


